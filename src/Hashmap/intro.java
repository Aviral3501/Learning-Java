package Hashmap;

public class intro {
//    -----------------------------------------------------------------------------------------------------------
//    Why doe we need hashmap ?
//    Even in BST , to search an element time complexity is O(log n)
//    What if i want to get an element in O(1) time complexity ,  this can be done using hashmaps.
//    In hashmaps the data is stored in key-value pairs.
//    e.g.
//            key       |      value  |
//           | -----------------------|
//           | Avi       |     88     |
//           | Sail      |     89     |
//           | Prabhakar |     86     |
//           | Paul      |     89     |
//           |------------------------|

    /*
    How to get an element ?
    e.g.  map.get("Sail");   --> it will directly give me value of  key->"Sail" i.e. 89
    in O(1) time complexity, it will not search the entire hashmap one by one, but will directly give the value.


    Real World Implementations of Hashmap --->
    1)In compilers // interpreters to pint the names to the variables.
    2)In network routers, to map the ip addresses in constant time.

    How the hashmap works ?????  ------>

    |--------------------------------------------------|
    | Avi   |  Sam   | Pra   |  Par  | Ak   |  Justin  |
    |__________________________________________________|
                                            |
                                            |
    Suppose this is the array sample   <-----

    To understand hashmap first understand Hashcode  --->  hashcode is the way of getting a number.
    Generating function is the one which generates the hashcode.(using some formula)
    No matter what you give the generating function (object , string , integer) it will generate a number out of it.
    i.e. The KEYS WILL BE POSITIVE NUMBERS (always).

    There are two problems associated with hashmaps --->
    1) All keys must be numbers (can be done using some formula).
    2)Hashcode generated can be very large, hence we need to reduce it----> a.k.a HASHING , eg lets say we need
     to reduce hashcode to number less than 10.3244234 --> hashingFunction() --> lets say 5  i.e. <10
     We can say that we store the value at the index generated by hashingFunction();

    ----->hashcode of an Integer is the integer itself (as it is unique in itself) <----------------


    |----------------------------------------------------------|
    | Avi   |  Sam   | Pra   |  Par  | Ak   |  Justin  |       |
    |__________________________________________________________|

    "Avi"  -----------> hashCode("Avi") ----------> 3245436 (make it small) ----------> 3 i.e. <10
                    (generating func.)           (integer code)              (hashing)

    Now the problem is that even though we may not have same hashcode for all values , but the hashingValue
    may be same for different values.

    When you get multiple indices to store different values ------> COLLISION OCCURS
    Collision ---> When multiple values are to be stored at the same index.

     How do we deal with Collision ??   ---->
     Well there are multiple ways  -->
     1) Chaining
     2)
     3)
     4)


     */

//    -----------------------------------------------------------------------------------------------------------
}
