package Hashmap;

public class intro {
//    -----------------------------------------------------------------------------------------------------------
//    Why doe we need hashmap ?
//    Even in BST , to search an element time complexity is O(log n)
//    What if i want to get an element in O(1) time complexity ,  this can be done using hashmaps.
//    In hashmaps the data is stored in key-value pairs.
//    e.g.
//            key       |      value  |
//           | -----------------------|
//           | Avi       |     88     |
//           | Sail      |     89     |
//           | Prabhakar |     86     |
//           | Paul      |     89     |
//           |------------------------|

    /*
    How to get an element ?
    e.g.  map.get("Sail");   --> it will directly give me value of  key->"Sail" i.e. 89
    in O(1) time complexity, it will not search the entire hashmap one by one, but will directly give the value.


    Real World Implementations of Hashmap --->
    1)In compilers // interpreters to pint the names to the variables.
    2)In network routers, to map the ip addresses in constant time.

    How the hashmap works ?????  ------>

    |--------------------------------------------------|
    | Avi   |  Sam   | Pra   |  Par  | Ak   |  Justin  |
    |__________________________________________________|
                                            |
                                            |
    Suppose this is the array sample   <-----

    To understand hashmap first understand Hashcode  --->  hashcode is the way of getting a number.
    Generating function is the one which generates the hashcode.(using some formula)
    No matter what you give the generating function (object , string , integer) it will generate a number out of it.
    i.e. The KEYS WILL BE POSITIVE NUMBERS (always).

    There are two problems associated with hashmaps --->
    1) All keys must be numbers (can be done using some formula).
    2)Hashcode generated can be very large, hence we need to reduce it----> a.k.a HASHING , eg lets say we need
     to reduce hashcode to number less than 10.3244234 --> hashingFunction() --> lets say 5  i.e. <10
     We can say that we store the value at the index generated by hashingFunction();

    ----->hashcode of an Integer is the integer itself (as it is unique in itself) <----------------


    |----------------------------------------------------------|
    | Avi   |  Sam   | Pra   |  Par  | Ak   |  Justin  |       |
    |__________________________________________________________|

    "Avi"  -----------> hashCode("Avi") ----------> 3245436 (make it small) ----------> 3 i.e. <10
                    (generating func.)           (integer code)              (hashing)

    Now the problem is that even though we may not have same hashcode for all values , but the hashingValue
    may be same for different values.

    When you get multiple indices to store different values ------> COLLISION OCCURS
    Collision ---> When multiple values are to be stored at the same index.

     How do we deal with Collision ??   ---->
     Well there are multiple ways  -->
     1) Chaining
     2) Open Addressing


     1)CHAINING -------->

     hashingFunction ( modulo , midSquare , etc) will generate the index where the value will be stored

    |----------------------------------------------------------|
    |       |  Kun   |       |  Avi  | Bar  |    Viper |       |
    |__________________________________________________________|
       |                |     ( same as last i.e. Ben )    |
       |                |                                  |
       v                v                                  v
     |-----|         |------|                            |-----|
     | V1  |         | V'1  |                            | Ben |
     |-----|         |------|                            |_____|
     | V2  |         | V'2  |
     |-----|         |______|
     | V3  |
     |_____|

    in chaining each value is stored as a node at an index , now if same index is generated for multiple elements
    then each element is added next to the node(if present) else a single node is referenced e.g. Avi,Bar,Viper,Ben

    worst case here is, it may become a linked list i.e. O(log n)  at a particular index.

    ======================    WORST CASE SCENARIO    ====================================

    |----------------------------------------------------------|
    |       |        |       |       |      |          |       |
    |__________________________________________________________|
       |
       |
       v
     |-----|
     | V1  |
     |-----|
     | V2  |
     |-----|
     | V3  |
     |-----|
     | V4  |
     |-----|      Linked list hi ban gayi , bt ho gyi
     | V5  |
     |_____|

     So how do we prevent this, we try our best to make sure that we don't get multiple elements at the
     same index.


     2) Open Addressing

     --> only one item per slot of the table

                                |------------------|
              h(33,0)---------->|       45         |  (cannot be inserted as element is already there)
                                |------------------|
              h(33,2)---------->|                  |  < can be inserted >  hurrah
                                |------------------|
                                |        434       |
                                |------------------|
                                |                  |
                                |------------------|
             h(33,1)----------->|       324        |  (cannot be inserted as element is already there)
                                |------------------|
                                |                  |
                                |__________________|

            h(33,n) ---> insert the element 33 , in n-1 th try   , for first try the index was 0 (filled) ,
            on next iteration the index was 4(filled) , on next try the index was 2 (we can insert 33 there)

            PROBING ---> Until we get the next possible index(empty) we will keep on iterating(hashing) and insert the value

            Probing strategies --->
            1)Linear Probing  (linearly jump all the indices , problem --> clustering)
            2)Double Hashing





     */

//    -----------------------------------------------------------------------------------------------------------
}
